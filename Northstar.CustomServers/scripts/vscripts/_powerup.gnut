untyped
global function PowerUps_Init

struct {
	array<entity> powerupSpawns
} file

void function PowerUps_Init()
{
	SH_PowerUp_Init()
		
	AddSpawnCallbackEditorClass( "script_ref", "script_power_up_other", AddPowerupSpawn )
	AddCallback_OnTouchHealthKit( "item_powerup", OnPowerupCollected )
}

void function AddPowerupSpawn( entity spawnpoint )
{
	file.powerupSpawns.append( spawnpoint )
}

void function RespawnPowerups()
{
	foreach ( entity spawnpoint in file.powerupSpawns )
	{
		PowerUp powerupDef = GetPowerUpFromItemRef( expect string( spawnpoint.kv.powerUpType ) )
		thread PowerupSpawnerThink( spawnpoint, powerupDef )
	}
}

void function PowerupSpawnerThink( entity spawnpoint, PowerUp powerupDef )
{
	svGlobal.levelEnt.EndSignal( "CleanUpEntitiesForRoundEnd" )

	entity base = CreatePropDynamic( powerupDef.baseModel, spawnpoint.GetOrigin(), spawnpoint.GetAngles(), 2 )
	OnThreadEnd( function() : ( base ) 
	{
		base.Destroy()
	})

	while ( true )
	{
		if ( !powerupDef.spawnFunc() )
		{
			// unsure if this is the best way of doing it
			WaitFrame()
			continue
		}
						
		entity powerup = CreateEntity( "item_powerup" )
		
		powerup.SetParent( base ) // parenting ensures that gravity isn't an issue
		powerup.SetValueForModelKey( powerupDef.model )
		
		DispatchSpawn( powerup )
		
		// offset from parent's position/angles
		powerup.SetOrigin( powerupDef.modelOffset )
		powerup.SetAngles( powerupDef.modelAngles )
		
		powerup.SetModel( powerupDef.model )
		powerup.s.powerupRef <- powerupDef.itemRef
		
		PickupGlow glow = CreatePickupGlow( powerup, powerupDef.glowColor.x.tointeger(), powerupDef.glowColor.y.tointeger(), powerupDef.glowColor.z.tointeger() )
		glow.glowFX.SetOrigin( spawnpoint.GetOrigin() ) // want the glow to be parented to the powerup, but have the position of the spawnpoint
		
		OnThreadEnd( function() : ( powerup )
		{
			if ( IsValid( powerup ) )
			{
				powerup.Destroy()
			}
		})
		
		powerup.WaitSignal( "OnDestroy" )
		wait powerupDef.respawnDelay
	}
}

bool function OnPowerupCollected( entity player, entity healthpack )
{
	PowerUp powerup = GetPowerUpFromItemRef( expect string( healthpack.s.powerupRef ) )
	
	if ( player.IsTitan() == powerup.titanPickup )
	{
		// hack because i couldn't figure out any other way to do this without modifying sh_powerup
		// ensure we don't kill the powerup if it's a battery the player can't pickup
		if ( ( powerup.index == ePowerUps.titanTimeReduction || powerup.index == ePowerUps.LTS_TitanTimeReduction ) && PlayerHasBattery( player ) )
			return false
	
		powerup.destroyFunc( player )
		return true // destroys the powerup
	}
	
	return false // keeps powerup alive
}